import React, {useContext, useEffect, useState} from 'react';
import {
    AlertDialog,
    Button,
    CardActions,
    Notification,
    Pagination,
    Spacing,
    Spinner,
    Table,
} from '@gui-elements/index';
import {
    IAddedSuggestion,
    IPageSuggestion,
    IPlainObject,
    IPrefix,
    ISortDirection,
    ITableHeader,
    ITargetWithSelected,
    ITransformedSuggestion
} from "./suggestion.typings";
import _ from 'lodash';
import paginate from "../../utils/paginate";
import STableBody from "./SuggestionTable/STableBody";
import STableHeader from "./SuggestionTable/STableHeader";
import {SuggestionListContext} from "./SuggestionContainer";
import {PrefixDialog} from "./PrefixDialog";
import {filterRowsByColumnModifier, sortRows} from "./utils";
import AppliedFilters from "./AppliedFilters";

interface IPagination {
    // store current page number
    page: number;
    // store page size
    pageSize: number;
}

interface IProps {
    // received native data from backend
    rows: ITransformedSuggestion[];

    // prefix list for autogenerated properties
    prefixList: IPrefix[];

    loading: boolean;

    // call parent action during column (source->target) swap
    onSwapAction();

    // call parent discard(cancel) action
    onAskDiscardChanges();

    // call parent add action
    onAdd(selected: IAddedSuggestion[], selectedPrefix: string);
}

export default function SuggestionList({rows, prefixList, loading, onSwapAction, onAskDiscardChanges, onAdd}: IProps) {
    const context = useContext(SuggestionListContext);

    const [headers, setHeaders] = useState<ITableHeader[]>(
        [
            {header: 'Source data', key: 'source'},
            {header: null, key: 'SWAP_BUTTON'},
            {header: 'Target data', key: 'target',},
            {header: 'Mapping type', key: 'type'}
        ]
    );

    // store all result, because without pagination
    const [allRows, setAllRows] = useState<IPageSuggestion[]>([]);

    // store rows for current page
    const [pageRows, setPageRows] = useState<IPageSuggestion[]>([]);

    // store all filtered rows by column
    const [filteredRows, setFilteredRows] = useState<IPageSuggestion[]>([]);

    // pagination info
    const [pagination, setPagination] = useState<IPagination>({
        page: 1,
        pageSize: 25
    });

    // stored selected source labels or uris
    const [selectedSources, setSelectedSources] = useState<string[]>([]);

    // store hashmap for source->target, invert values on swap action
    const [sourceToTargetMap, setSourceToTargetMap] = useState<IPlainObject>({});

    // store hashmap for target->type, replace target with source on swap action
    const [targetToTypeMap, setTargetToTypeMap] = useState<any>({});

    // keep sort directions for columns
    const [sortDirections, setSortDirections] = useState<ISortDirection>({
        column: '',
        modifier: false
    });

    // contain columns filters
    const [columnFilters, setColumnFilters] = useState<{ [key: string]: string }>({});

    // show the warning dialog when user try to swap the columns,for autogenerated properties
    const [warningDialog, setWarningDialog] = useState<boolean>(false);

    // show the prefix modal when add the autogenerated values
    const [prefixModal, setPrefixModal] = useState(false);

    useEffect(() => {
        const arr = [];

        rows.forEach((row) => {
            const {candidates} = row;

            // add _selected field for each target
            const modifiedTarget = candidates.map(targetItem => ({
                ...targetItem,
                _selected: false
            }));

            // store modified source,target
            const modifiedRow: IPageSuggestion = {
                ...row,
                candidates: modifiedTarget,
            };

            // keep changes for selected items only after swap action
            if (selectedSources.includes(row.uri)) {
                modifiedRow.candidates = modifiedRow.candidates.map(targetItem => {
                    const {label, description, uri, type, confidence, link} = targetItem;
                    return {
                        uri,
                        confidence,
                        label,
                        description,
                        link,
                        type: targetToTypeMap[uri] || type,
                        _selected: sourceToTargetMap[row.uri] === uri
                    }
                });
            }

            if (context.isFromDataset) {
                modifiedRow.candidates.push({
                    uri: '',
                    label: 'Auto-generated property',
                    description: 'Property will generated after submit',
                    type: 'value',
                    link: 'https://dummy.url',
                    _selected: !modifiedRow.candidates.length,
                    _autogenerated: true,
                    confidence: 1
                });
            }

            // in case nothing selected, then select first item
            const someSelected = modifiedRow.candidates.some(t => t._selected);
            if (!someSelected) {
                modifiedRow.candidates[0]._selected = true;
            }

            arr.push(modifiedRow);
        });

        setAllRows(arr);

        const filteredRows = filterRowsByColumnModifier(columnFilters, selectedSources, arr);
        setFilteredRows(filteredRows);

        const ordered = sortRows(filteredRows, sortDirections);
        setPageRows(
            paginate(ordered, pagination)
        );

    }, [rows]);

    // update the source -> target and target->map relactions on swap
    const updateRelations = (source, targets: ITargetWithSelected[]) => {
        const {uri, type} = targets.find(t => t._selected);

        setSourceToTargetMap(prevState => ({
            ...prevState,
            [source]: uri
        }));

        setTargetToTypeMap(prevState => ({
            ...prevState,
            [uri]: type
        }));
    };

    const toggleRowSelect = ({uri, candidates}: IPageSuggestion) => {
        const selectedRow = selectedSources.find(selected => selected === uri);
        if (selectedRow) {
            setSelectedSources(
                selectedSources.filter(selected => selected !== uri)
            );
        } else {
            setSelectedSources(prevState => ([
                ...prevState,
                uri,
            ]));
            updateRelations(uri, candidates);
        }
    };

    const toggleSelectAll = (scope: 'all' | 'page', action: 'select' | 'unselect') => {
        const scopeRows = scope === 'all' ? allRows : pageRows;
        if (action === 'select') {
            setSelectedSources(
                scopeRows.map(row => {
                    updateRelations(row.uri, row.candidates);
                    return row.uri;
                })
            );
        } else {
            if (scope === 'all')  {
                setSelectedSources([]);
            } else {
                const pageRowSources = pageRows.map(r => r.uri);
                setSelectedSources(
                    selectedSources.filter(row => !pageRowSources.includes(row))
                );
            }
        }
    };

    const handlePageChange = (pagination: IPagination) => {
        setPagination(pagination);
        setPageRows(
            paginate(filteredRows, pagination)
        );
    };

    // this function called from prefixDialog and from save button
    // when prefix is not presented then open modal for autogenrated properties
    // otherwise save prefix in localstorage
    const handleAdd = (e, prefix?: string) => {
        const addedRows = selectedSources.map(source => {
            const found = allRows.find(row => row.uri === source);
            if (found) {
                const target = found.candidates.find(t => t._selected);
                return {
                    source,
                    targetUri: target.uri,
                    type: target.type
                }
            }
        });

        const isAutogeneratedPresents = addedRows.some(
            // autogenerated values contains empty uri
            row => row.targetUri === ''
        );

        if (isAutogeneratedPresents) {
          if (typeof prefix === 'undefined') {
              setPrefixModal(true);
              return;
          }  else {
              localStorage.setItem('prefix', prefix);
          }
        }

        onAdd(addedRows, prefix);
    }

    const handleSort = (headerKey: string) => {
        let direction: any = 'asc';
        if (sortDirections.column === headerKey) {
            direction = sortDirections.modifier === false
                ? 'asc'
                : sortDirections.modifier === 'asc' ? 'desc' : false;
        }

        let sortedArray = [...filteredRows];
        const newDirection: ISortDirection = {
            column: '',
            modifier: false
        };

        if (direction !== false) {
            newDirection.column = headerKey;
            newDirection.modifier = direction;

            sortedArray = sortRows(filteredRows, newDirection);
        }
        setSortDirections(newDirection);

        setPageRows(
            paginate(sortedArray, pagination)
        );
    };

    const handleFilterColumn = (columnName: string, action: string, forceRemove?: boolean) => {
        let colFilters = {...columnFilters};
        if (colFilters[columnName] === action || forceRemove) {
            delete colFilters[columnName]
        } else {
            colFilters[columnName] = action;
        }

        setColumnFilters(colFilters);

        const filteredRows = filterRowsByColumnModifier(colFilters, selectedSources, allRows);
        setPageRows(
            paginate(filteredRows, pagination)
        );
        setFilteredRows(filteredRows);
    };

    const handleSwap = () => {
        const isAutogeneratedSelected = selectedSources.some(source => {
            const found = allRows.find(row => row.uri === source);
            if (found) {
                const {_autogenerated} = found.candidates.find(t => t._selected);
                return _autogenerated;
            }
        });

        if (isAutogeneratedSelected) {
            setWarningDialog(true);
            return;
        }

        handleConfirmSwap();
    };

    const handleConfirmSwap = () => {
        const targetsAsSelected = selectedSources.map(source => {
            const found = allRows.find(row => row.uri === source);
            if (found) {
                const {uri, _autogenerated} = found.candidates.find(t => t._selected);
                if (_autogenerated) {
                    return null;
                }
                return uri;
            }
        }).filter(Boolean);

        setSelectedSources(targetsAsSelected);

        // reset preview rows
        setPageRows([]);

        const sourceToType = {};
        const targetToSource = _.invert(sourceToTargetMap);

        _.forEach(targetToTypeMap, (value, key) => {
            const source = targetToSource[key];
            sourceToType[source] = value;
        });

        setSourceToTargetMap(targetToSource);
        setTargetToTypeMap(sourceToType);

        // swap header columns
        const temp = headers[0];
        headers[0] = headers[2];
        headers[2] = temp;

        setHeaders(headers);

        setWarningDialog(false);

        onSwapAction();
    };

    // modify suggestion.candidates[] fields
    const handleModifyTarget = (row: IPageSuggestion, targets: ITargetWithSelected[]) => {
        const _allRows = [...allRows];
        const ind = _allRows.findIndex(r => r.uri === row.uri);

        if (ind > -1) {
            updateRelations(row.uri, targets);

            _allRows[ind].candidates = targets;

            setAllRows(_allRows);
        }
    }

    const isAllSelected = () => filteredRows.length && pageRows.length === selectedSources.length;

    return loading ? <Spinner/> :
        <>
            {!!Object.keys(columnFilters).length &&
                <AppliedFilters
                    filters={columnFilters}
                    onRemove={(key) => handleFilterColumn(key, '', true)}
                />
            }
            {
                filteredRows.length === 0 ? (
                    <Notification>No results found.</Notification>
                ) : (
                    <Table>
                        <STableHeader
                            headers={headers}
                            isAllSelected={isAllSelected()}
                            toggleSelectAll={toggleSelectAll}
                            onSwap={handleSwap}
                            onSort={handleSort}
                            onApplyFilter={handleFilterColumn}
                            sortDirections={sortDirections}
                            appliedFilters={columnFilters}
                            ratioSelection={selectedSources.length / rows.length}
                        />
                        <STableBody
                            pageRows={pageRows}
                            selectedSources={selectedSources}
                            toggleRowSelect={toggleRowSelect}
                            onModifyTarget={handleModifyTarget}
                        />
                    </Table>
                )
            }
            {
                filteredRows.length > 0 && (
                    <Pagination
                        onChange={handlePageChange}
                        totalItems={filteredRows.length}
                        pageSizes={[5, 10, 25, 50, 100]}
                        page={pagination.page}
                        pageSize={pagination.pageSize}
                        backwardText={"Previous page"}
                        forwardText={"Next page"}
                        itemsPerPageText={"Items per page:"}
                        itemRangeText={(min, max, total) => `${min}–${max} of ${total} items`}
                        pageRangeText={(current, total) => `of ${total} pages`}
                    />
                )
            }
            <Spacing size="small"/>
            <CardActions>
                <Button affirmative={allRows.length > 0} disabled={allRows.length < 1} onClick={handleAdd} data-test-id='add_button'>
                    Add ({selectedSources.length})
                </Button>
                <Button onClick={onAskDiscardChanges}>Cancel</Button>
            </CardActions>
            <AlertDialog
                warning={true}
                isOpen={warningDialog}
                portalContainer={context.portalContainer}
                onClose={() => setWarningDialog(false)}
                actions={[
                    <Button key="confirm" onClick={handleConfirmSwap}>
                        Swap
                    </Button>,
                    <Button key="cancel" onClick={() => setWarningDialog(false)}>
                        Cancel
                    </Button>,
                ]}
            >
                <p>The selected auto-generated properties lost after swap.</p>
                <p>Are you sure?</p>
            </AlertDialog>
            <PrefixDialog
                isOpen={prefixModal}
                onAdd={handleAdd}
                onDismiss={() => setPrefixModal(false)}
                prefixList={prefixList}
                selectedPrefix={localStorage.getItem('prefix') || ''}
            />
        </>
}
